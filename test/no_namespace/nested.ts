/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.19.1
 * source: test/_/no_namespace/nested.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
import * as grpc_1 from "@grpc/grpc-js";
export enum Type {
    HTTP = 0,
    DATABASE = 1,
    SCHEDULE = 3,
    FIREHOSE = 4,
    SYSTEM = 5,
    BUCKET = 6
}
export class SchedulingContext extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        env?: SchedulingContextEnv[];
        timeout?: number;
        batch?: SchedulingContextBatch;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("env" in data && data.env != undefined) {
                this.env = data.env;
            }
            if ("timeout" in data && data.timeout != undefined) {
                this.timeout = data.timeout;
            }
            if ("batch" in data && data.batch != undefined) {
                this.batch = data.batch;
            }
        }
    }
    get env() {
        return pb_1.Message.getRepeatedWrapperField(this, SchedulingContextEnv, 2) as SchedulingContextEnv[];
    }
    set env(value: SchedulingContextEnv[]) {
        pb_1.Message.setRepeatedWrapperField(this, 2, value);
    }
    get timeout() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set timeout(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    get batch() {
        return pb_1.Message.getWrapperField(this, SchedulingContextBatch, 4) as SchedulingContextBatch | undefined;
    }
    set batch(value: SchedulingContextBatch | undefined) {
        pb_1.Message.setWrapperField(this, 4, value);
    }
    get has_batch() {
        return pb_1.Message.getField(this, 4) != null;
    }
    clear_batch(): void {
        this.batch = undefined!;
    }
    static fromObject(data?: SchedulingContextAsObjectPartial): SchedulingContext {
        if (!data) {
            return new SchedulingContext();
        }
        const message = new SchedulingContext({});
        if (data.env != null) {
            message.env = data.env.map(item => SchedulingContextEnv.fromObject(item));
        }
        if (data.timeout != null) {
            message.timeout = data.timeout;
        }
        if (data.batch != null) {
            message.batch = SchedulingContextBatch.fromObject(data.batch);
        }
        return message;
    }
    toObject() {
        const data: SchedulingContextAsObject = {
            env: this.env.map((item: SchedulingContextEnv) => item.toObject()),
            timeout: this.timeout
        };
        if (this.batch != null) {
            data.batch = this.batch.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.env.length)
            writer.writeRepeatedMessage(2, this.env, (item: SchedulingContextEnv) => item!.serialize(writer));
        if (this.timeout != 0)
            writer.writeInt32(3, this.timeout);
        if (this.has_batch)
            writer.writeMessage(4, this.batch, () => this.batch!.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SchedulingContext {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SchedulingContext();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 2:
                    reader.readMessage(message.env, () => pb_1.Message.addToRepeatedWrapperField(message, 2, SchedulingContextEnv.deserialize(reader), SchedulingContextEnv));
                    break;
                case 3:
                    message.timeout = reader.readInt32();
                    break;
                case 4:
                    reader.readMessage(message.batch, () => message.batch = SchedulingContextBatch.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): SchedulingContext {
        return SchedulingContext.deserialize(bytes);
    }
}
export type SchedulingContextAsObject = {
    env: SchedulingContextEnvAsObject[];
    timeout: number;
    batch?: SchedulingContextBatchAsObject;
};
export type SchedulingContextAsObjectPartial = {
    env?: SchedulingContextEnvAsObjectPartial[];
    timeout?: number;
    batch?: SchedulingContextBatchAsObjectPartial;
};
export class SchedulingContextEnv extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        key?: string;
        value?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("key" in data && data.key != undefined) {
                this.key = data.key;
            }
            if ("value" in data && data.value != undefined) {
                this.value = data.value;
            }
        }
    }
    get key() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set key(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get value() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set value(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data?: SchedulingContextEnvAsObjectPartial): SchedulingContextEnv {
        if (!data) {
            return new SchedulingContextEnv();
        }
        const message = new SchedulingContextEnv({});
        if (data.key != null) {
            message.key = data.key;
        }
        if (data.value != null) {
            message.value = data.value;
        }
        return message;
    }
    toObject() {
        const data: SchedulingContextEnvAsObject = {
            key: this.key,
            value: this.value
        };
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.key.length)
            writer.writeString(1, this.key);
        if (this.value.length)
            writer.writeString(2, this.value);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SchedulingContextEnv {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SchedulingContextEnv();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.key = reader.readString();
                    break;
                case 2:
                    message.value = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): SchedulingContextEnv {
        return SchedulingContextEnv.deserialize(bytes);
    }
}
export type SchedulingContextEnvAsObject = {
    key: string;
    value: string;
};
export type SchedulingContextEnvAsObjectPartial = {
    key?: string;
    value?: string;
};
export class SchedulingContextBatch extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        limit?: number;
        deadline?: number;
        process?: SchedulingContextBatchProcess;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("limit" in data && data.limit != undefined) {
                this.limit = data.limit;
            }
            if ("deadline" in data && data.deadline != undefined) {
                this.deadline = data.deadline;
            }
            if ("process" in data && data.process != undefined) {
                this.process = data.process;
            }
        }
    }
    get limit() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set limit(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get deadline() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set deadline(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    get process() {
        return pb_1.Message.getWrapperField(this, SchedulingContextBatchProcess, 3) as SchedulingContextBatchProcess | undefined;
    }
    set process(value: SchedulingContextBatchProcess | undefined) {
        pb_1.Message.setWrapperField(this, 3, value);
    }
    get has_process() {
        return pb_1.Message.getField(this, 3) != null;
    }
    clear_process(): void {
        this.process = undefined!;
    }
    static fromObject(data?: SchedulingContextBatchAsObjectPartial): SchedulingContextBatch {
        if (!data) {
            return new SchedulingContextBatch();
        }
        const message = new SchedulingContextBatch({});
        if (data.limit != null) {
            message.limit = data.limit;
        }
        if (data.deadline != null) {
            message.deadline = data.deadline;
        }
        if (data.process != null) {
            message.process = SchedulingContextBatchProcess.fromObject(data.process);
        }
        return message;
    }
    toObject() {
        const data: SchedulingContextBatchAsObject = {
            limit: this.limit,
            deadline: this.deadline
        };
        if (this.process != null) {
            data.process = this.process.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.limit != 0)
            writer.writeUint64(1, this.limit);
        if (this.deadline != 0)
            writer.writeUint64(2, this.deadline);
        if (this.has_process)
            writer.writeMessage(3, this.process, () => this.process!.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SchedulingContextBatch {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SchedulingContextBatch();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.limit = reader.readUint64();
                    break;
                case 2:
                    message.deadline = reader.readUint64();
                    break;
                case 3:
                    reader.readMessage(message.process, () => message.process = SchedulingContextBatchProcess.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): SchedulingContextBatch {
        return SchedulingContextBatch.deserialize(bytes);
    }
}
export type SchedulingContextBatchAsObject = {
    limit: number;
    deadline: number;
    process?: SchedulingContextBatchProcessAsObject;
};
export type SchedulingContextBatchAsObjectPartial = {
    limit?: number;
    deadline?: number;
    process?: SchedulingContextBatchProcessAsObjectPartial;
};
export class SchedulingContextBatchProcess extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        id?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("id" in data && data.id != undefined) {
                this.id = data.id;
            }
        }
    }
    get id() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set id(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data?: SchedulingContextBatchProcessAsObjectPartial): SchedulingContextBatchProcess {
        if (!data) {
            return new SchedulingContextBatchProcess();
        }
        const message = new SchedulingContextBatchProcess({});
        if (data.id != null) {
            message.id = data.id;
        }
        return message;
    }
    toObject() {
        const data: SchedulingContextBatchProcessAsObject = {
            id: this.id
        };
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.id.length)
            writer.writeString(1, this.id);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SchedulingContextBatchProcess {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SchedulingContextBatchProcess();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.id = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): SchedulingContextBatchProcess {
        return SchedulingContextBatchProcess.deserialize(bytes);
    }
}
export type SchedulingContextBatchProcessAsObject = {
    id: string;
};
export type SchedulingContextBatchProcessAsObjectPartial = {
    id?: string;
};
export class Target extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        id?: string;
        cwd?: string;
        handler?: string;
        context?: SchedulingContext;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("id" in data && data.id != undefined) {
                this.id = data.id;
            }
            if ("cwd" in data && data.cwd != undefined) {
                this.cwd = data.cwd;
            }
            if ("handler" in data && data.handler != undefined) {
                this.handler = data.handler;
            }
            if ("context" in data && data.context != undefined) {
                this.context = data.context;
            }
        }
    }
    get id() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set id(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get cwd() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set cwd(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get handler() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set handler(value: string) {
        pb_1.Message.setField(this, 3, value);
    }
    get context() {
        return pb_1.Message.getWrapperField(this, SchedulingContext, 4) as SchedulingContext | undefined;
    }
    set context(value: SchedulingContext | undefined) {
        pb_1.Message.setWrapperField(this, 4, value);
    }
    get has_context() {
        return pb_1.Message.getField(this, 4) != null;
    }
    clear_context(): void {
        this.context = undefined!;
    }
    static fromObject(data?: TargetAsObjectPartial): Target {
        if (!data) {
            return new Target();
        }
        const message = new Target({});
        if (data.id != null) {
            message.id = data.id;
        }
        if (data.cwd != null) {
            message.cwd = data.cwd;
        }
        if (data.handler != null) {
            message.handler = data.handler;
        }
        if (data.context != null) {
            message.context = SchedulingContext.fromObject(data.context);
        }
        return message;
    }
    toObject() {
        const data: TargetAsObject = {
            id: this.id,
            cwd: this.cwd,
            handler: this.handler
        };
        if (this.context != null) {
            data.context = this.context.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.id.length)
            writer.writeString(1, this.id);
        if (this.cwd.length)
            writer.writeString(2, this.cwd);
        if (this.handler.length)
            writer.writeString(3, this.handler);
        if (this.has_context)
            writer.writeMessage(4, this.context, () => this.context!.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Target {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Target();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.id = reader.readString();
                    break;
                case 2:
                    message.cwd = reader.readString();
                    break;
                case 3:
                    message.handler = reader.readString();
                    break;
                case 4:
                    reader.readMessage(message.context, () => message.context = SchedulingContext.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Target {
        return Target.deserialize(bytes);
    }
}
export type TargetAsObject = {
    id: string;
    cwd: string;
    handler: string;
    context?: SchedulingContextAsObject;
};
export type TargetAsObjectPartial = {
    id?: string;
    cwd?: string;
    handler?: string;
    context?: SchedulingContextAsObjectPartial;
};
export class Event extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        id?: string;
        type?: Type;
        target?: Target;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("id" in data && data.id != undefined) {
                this.id = data.id;
            }
            if ("type" in data && data.type != undefined) {
                this.type = data.type;
            }
            if ("target" in data && data.target != undefined) {
                this.target = data.target;
            }
        }
    }
    get id() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set id(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get type() {
        return pb_1.Message.getFieldWithDefault(this, 2, Type.HTTP) as Type;
    }
    set type(value: Type) {
        pb_1.Message.setField(this, 2, value);
    }
    get target() {
        return pb_1.Message.getWrapperField(this, Target, 3) as Target | undefined;
    }
    set target(value: Target | undefined) {
        pb_1.Message.setWrapperField(this, 3, value);
    }
    get has_target() {
        return pb_1.Message.getField(this, 3) != null;
    }
    clear_target(): void {
        this.target = undefined!;
    }
    static fromObject(data?: EventAsObjectPartial): Event {
        if (!data) {
            return new Event();
        }
        const message = new Event({});
        if (data.id != null) {
            message.id = data.id;
        }
        if (data.type != null) {
            message.type = data.type;
        }
        if (data.target != null) {
            message.target = Target.fromObject(data.target);
        }
        return message;
    }
    toObject() {
        const data: EventAsObject = {
            id: this.id,
            type: this.type
        };
        if (this.target != null) {
            data.target = this.target.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.id.length)
            writer.writeString(1, this.id);
        if (this.type != Type.HTTP)
            writer.writeEnum(2, this.type);
        if (this.has_target)
            writer.writeMessage(3, this.target, () => this.target!.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Event {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Event();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.id = reader.readString();
                    break;
                case 2:
                    message.type = reader.readEnum();
                    break;
                case 3:
                    reader.readMessage(message.target, () => message.target = Target.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Event {
        return Event.deserialize(bytes);
    }
}
export type EventAsObject = {
    id: string;
    type: Type;
    target?: TargetAsObject;
};
export type EventAsObjectPartial = {
    id?: string;
    type?: Type;
    target?: TargetAsObjectPartial;
};
export class Pop extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        id?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("id" in data && data.id != undefined) {
                this.id = data.id;
            }
        }
    }
    get id() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set id(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data?: PopAsObjectPartial): Pop {
        if (!data) {
            return new Pop();
        }
        const message = new Pop({});
        if (data.id != null) {
            message.id = data.id;
        }
        return message;
    }
    toObject() {
        const data: PopAsObject = {
            id: this.id
        };
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.id.length)
            writer.writeString(1, this.id);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Pop {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Pop();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.id = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Pop {
        return Pop.deserialize(bytes);
    }
}
export type PopAsObject = {
    id: string;
};
export type PopAsObjectPartial = {
    id?: string;
};
export class Complete extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        id?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("id" in data && data.id != undefined) {
                this.id = data.id;
            }
        }
    }
    get id() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set id(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data?: CompleteAsObjectPartial): Complete {
        if (!data) {
            return new Complete();
        }
        const message = new Complete({});
        if (data.id != null) {
            message.id = data.id;
        }
        return message;
    }
    toObject() {
        const data: CompleteAsObject = {
            id: this.id
        };
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.id.length)
            writer.writeString(1, this.id);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Complete {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Complete();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.id = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Complete {
        return Complete.deserialize(bytes);
    }
}
export type CompleteAsObject = {
    id: string;
};
export type CompleteAsObjectPartial = {
    id?: string;
};
export class CompleteResult extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {}) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") { }
    }
    static fromObject(data?: CompleteResultAsObjectPartial): CompleteResult {
        if (!data) {
            return new CompleteResult();
        }
        const message = new CompleteResult({});
        return message;
    }
    toObject() {
        const data: CompleteResultAsObject = {};
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CompleteResult {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CompleteResult();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): CompleteResult {
        return CompleteResult.deserialize(bytes);
    }
}
export type CompleteResultAsObject = {};
export type CompleteResultAsObjectPartial = {};
interface GrpcUnaryServiceInterface<P, R> {
    (message: P, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    (message: P, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    (message: P, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    (message: P, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
}
interface GrpcStreamServiceInterface<P, R> {
    (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
    (message: P, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
}
interface GrpWritableServiceInterface<P, R> {
    (metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    (metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    (options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    (callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
}
interface GrpcChunkServiceInterface<P, R> {
    (metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
    (options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
}
interface GrpcPromiseServiceInterface<P, R> {
    (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): Promise<R>;
    (message: P, options?: grpc_1.CallOptions): Promise<R>;
}
export abstract class UnimplementedQueueService {
    static definition = {
        pop: {
            path: "/event.Queue/pop",
            requestStream: false,
            responseStream: false,
            requestSerialize: (message: Pop) => Buffer.from(message.serialize()),
            requestDeserialize: (bytes: Buffer) => Pop.deserialize(new Uint8Array(bytes)),
            responseSerialize: (message: Event) => Buffer.from(message.serialize()),
            responseDeserialize: (bytes: Buffer) => Event.deserialize(new Uint8Array(bytes))
        },
        complete: {
            path: "/event.Queue/complete",
            requestStream: false,
            responseStream: false,
            requestSerialize: (message: Complete) => Buffer.from(message.serialize()),
            requestDeserialize: (bytes: Buffer) => Complete.deserialize(new Uint8Array(bytes)),
            responseSerialize: (message: CompleteResult) => Buffer.from(message.serialize()),
            responseDeserialize: (bytes: Buffer) => CompleteResult.deserialize(new Uint8Array(bytes))
        }
    };
    [method: string]: grpc_1.UntypedHandleCall;
    abstract pop(call: grpc_1.ServerUnaryCall<Pop, Event>, callback: grpc_1.sendUnaryData<Event>): void;
    abstract complete(call: grpc_1.ServerUnaryCall<Complete, CompleteResult>, callback: grpc_1.sendUnaryData<CompleteResult>): void;
}
export class QueueClient extends grpc_1.makeGenericClientConstructor(UnimplementedQueueService.definition, "Queue", {}) {
    constructor(address: string, credentials: grpc_1.ChannelCredentials, options?: Partial<grpc_1.ChannelOptions>) {
        super(address, credentials, options);
    }
    pop: GrpcUnaryServiceInterface<Pop, Event> = (message: Pop, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<Event>, options?: grpc_1.CallOptions | grpc_1.requestCallback<Event>, callback?: grpc_1.requestCallback<Event>): grpc_1.ClientUnaryCall => {
        return super["pop"]!(message, metadata, options, callback);
    };
    complete: GrpcUnaryServiceInterface<Complete, CompleteResult> = (message: Complete, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<CompleteResult>, options?: grpc_1.CallOptions | grpc_1.requestCallback<CompleteResult>, callback?: grpc_1.requestCallback<CompleteResult>): grpc_1.ClientUnaryCall => {
        return super["complete"]!(message, metadata, options, callback);
    };
}
